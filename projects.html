<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Projects</title>
    <link href="dark-mode.css" rel="stylesheet">
</head>
<body>
    <header>
        <nav id="header-nav">
            <a href="index.html">
                <button>Home</button>
            </a>
            <a href="about_me.html">
                <button>About Me</button>
            </a>
            <a href="skills.html">
                <button>Skills & Abilities</button>
            </a>
            <a href="projects.html">
                <button id="current-page">Projects</button></a>
            <a href="resume.html">
                <button>Résumé</button>
            </a>
            <a href="contact_me.html">
                <button>Contact Me</button>
            </a>
        </nav>
        <h1>Nandith's Digital Portfolio</h1>
    </header>
    <h1>My Projects</h1>
    <p>Here is a list of some of my Projects</p>
    <div class="project-card-grid">
        <card>
            <strong>Game Boy Emulator:</strong><br>
            <img src="resources/GBEmulatorProject.png" alt="Screenshot of my Game Boy Emulator running Tetris">
            <p>
                Over winter break, I wrote an emulator to play the original Game Boy games. It fetches machine instructions byte by byte from a ROM file, decodes them, and executes them.
                My emulator consists of four main components namely: the CPU(Central Processing Unit), the PPU(Pixel Processing Unit), the APU(Audio Processing Unit) and, the memory.
                The 8-bit CPU is a modified z80 chip which has 500 instructions and contains 8 8-bit registers, a stack pointer, and a program counter.
                Even though the Game Boy memory bus was only 16-bits wide, games could address upto 8MB of memory by switching out sections of memory.
                This is called Memory Banking and is handled by a Memory Bank Controller circuit located in the game's cartridge.
                The PPU and APU handle the graphics and audio functionalities of the Game Boy respectively.
                To make this emulator, I had to individually emulate each of these components and integrate them together.
            </p>
        </card>
        <card>
            <strong>Super Mario World AI:</strong><br>
            <img src="resources/MarioAIProject.png" alt="Screenshot of my AI autonomously playing Super Mario World">
            <p>
                For my Neural Networks class project, I trained a Neural Network to autonomously play Super Mario World.
                The one of the most crucial things a Neural Network needs is <strong><em>data</em></strong>.
                There are many ways to produce data for a Neural Network however, I decided to automate this task.
                So, I created a Neural Network that would create data for the main Neural Network.
                Now you might be thinking, "but how would you get data for the second Neural Network?".
                The solution to this problem was to write a Genetic Algorithm to train this secondary network.
                I wrote a special reward function which the Genetic Algorithm used to evaluate the performance of any given agent.
                After each generation, the weights of the best agents where mixed together along with a bit of mutation.
                This produced an agent that could complete individual levels of Super Mario World, but couldn't generalize between levels.
                I then recorded the actions that these agents were performing and used it as input data to my main network.
                This allowed the main network to learn to generalize and play multiple levels.
            </p>
        </card>
        <card>
            <strong>Mini-Java Compiler:</strong><br>
            <p>
                During Dr.Stansifer's Compiler Theory class, I wrote a mini-java to SPARK compiler in java.
                My compiler's features include supporting recursion, object-oriented programming, non-local variable access and, inheritance.
                In addition, it uses register spilling during register allocation to handle excess temps.
                To create the lexer and parser, I wrote a grammar and used a LL(k) parser-generator called JavaCC to generate them.
                Using the resulting parse tree, semantic analysis was done and a symbol table was constructed.
                The parse tree was converted into an intermediate representation and flattened.
                Now, instruction selection was performed after which, register allocation was also performed.
            </p>
        </card>
    </div>


</body>
</html>